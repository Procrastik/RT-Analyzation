   #Distance variance logic:
	#1. If DistantVarianceReversed false
	#  a) if DistantVariance > 1.0 - (0 <= distance <= DamageFalloffStartDistance) damage coeff = DistantVariance
	#                       (DamageFalloffStartDistance < distance < DamageFalloffEndDistance)
#						   damage coeff decrease from DistantVariance(at DamageFalloffStartDistance) to 1(at DamageFalloffEndDistance)
#	  b) if DistantVariance < 1.0 - (0 <= distance <= DamageFalloffStartDistance) damage coeff = 1
#	                       (DamageFalloffStartDistance < distance < DamageFalloffEndDistance)
#						   damage coeff decrease from 1(at DamageFalloffStartDistance) to DistantVariance(at DamageFalloffEndDistance)
#						   if DamageFalloffStartDistance is 0 assumed to be MediumRange
#						   if DamageFalloffEndDistance is less than DamageFalloffStartDistance assumed to be MaxRange
#	2. If DistantVarianceReversed true
#	  a) if DistantVariance > 1.0 - (0 <= distance <= DamageFalloffStartDistance) damage coeff = 1
#	                       (DamageFalloffStartDistance < distance < DamageFalloffEndDistance) 
#						   damage coeff grow from 1(at DamageFalloffStartDistance) to DistantVariance(at DamageFalloffEndDistance)
#						   (DamageFalloffEndDistance <= distance < MaxRange) damage coeff = DistantVariance
#	  b) if DistantVariance < 1.0 - (0 <= distance <= DamageFalloffStartDistance) damage coeff = DistantVariance
#	                       (DamageFalloffStartDistance < distance < DamageFalloffEndDistance) 
#						   damage coeff grow from DistantVariance(at DamageFalloffStartDistance) to 1(at DamageFalloffEndDistance)
#						   (DamageFalloffEndDistance <= distance < MaxRange) damage coeff = 1
#						   if DamageFalloffStartDistance is 0 assumed to be MinRange
#						   if DamageFalloffEndDistance is less than DamageFalloffStartDistance assumed to be MediumRange




	#"DistantVariance": 0.1,
 # "DistantVarianceReversed": true,
 # "isHeatVariation": true,
 # "isStabilityVariation": true,
 # "isDamageVariation": true,
 # "RangedDmgFalloffType": "Linear",
 # "DamageFalloffStartDistance": 30,
#  "DamageFalloffEndDistance": 600,
  
  #"DamageFalloffStartDistance": 0, - distance where damage starts to change, additive per ammo/mode/weapon.
 # "DamageFalloffEndDistance": 0, - distance where damage stops to change, additive per ammo/mode/weapon.
 # "DistantVariance": 0.3, - Distance damage variance addiditve per ammo/mode/weapon
 # "DistantVarianceReversed": false, - Set is distance damage variance is reversed (mode have priority, than ammo, than weapon)
 #"DistantVariance": 0.3, - Distance damage variance addiditve per ammo/mode/weapon
 # "DistantVarianceReversed": false, - Set is distance damage variance is reversed (mode have priority, than ammo, than weapon)
  
  
   #  public static float RangedDmgFalloffType(this Weapon weapon, float value)
    #{
     # switch (weapon.RangedDmgFalloffType())
     # {
      #  case DamageFalloffType.Quadratic:
      #    return value * value;
      #  case DamageFalloffType.Cubic:
      #    return value * value * value;
      #  case DamageFalloffType.SquareRoot:
      #    return Mathf.Sqrt(value);
      #  case DamageFalloffType.Log10:
      #    return Mathf.Log10(value);
      #  case DamageFalloffType.LogE:
      #    return Mathf.Log(value);
      #  case DamageFalloffType.Exp:
      #    return Mathf.Exp(value);
      #  case DamageFalloffType.Linear:
      #    return value;
      #  default:
      #    return value * value;
      #}
  
  public static float DistanceDamageMod(
      this Weapon weapon,
      Vector3 attackPos,
      ICombatant target,
      bool log = true)
    {
      float num1 = weapon.DistantVariance();
      float num2 = 1f;
      float num3 = Vector3.Distance(attackPos, target.get_TargetPosition());
      float num4 = weapon.DamageFalloffStartDistance();
      if ((double) num4 < (double) CustomAmmoCategories.Epsilon)
        num4 = weapon.get_MediumRange();
      float num5 = weapon.DamageFalloffEndDistance();
      if ((double) num5 < (double) num4)
        num5 = weapon.get_MaxRange();
      float num6 = 1f;
      if ((double) num5 - (double) num4 > (double) CustomAmmoCategories.Epsilon)
        num6 = (float) (((double) num3 - (double) num4) / ((double) num5 - (double) num4));
		#num6 (distanceratio) = 888 - 720 / 1440 - 720
      if ((double) num1 > 1.0)
        num2 = (double) num3 > (double) num4 ? num1 - weapon.RangedDmgFalloffType(num6) * (num1 - 1f) : num1;
      else if ((double) num1 < 1.0)
        num2 = (double) num3 > (double) num4 ? (float) (1.0 - (double) weapon.RangedDmgFalloffType(num6) * (1.0 - (double) num1)) : 1f;
      float num7 = num2;
      if (log)
        CustomAmmoCategoriesLog.Log.M.TWL(0, "defId: " + ((MechComponent) weapon).get_defId() + "\n" + string.Format("baseMultiplier: {0}\n", (object) num1) + string.Format("distance: {0}\n", (object) num3) + string.Format("start distance: {0}\n", (object) num4) + string.Format("end distance {0}\n", (object) num5) + string.Format("distanceRatio: {0}\n", (object) num6) + string.Format("result: {0}\n", (object) num7));
      return num7;
    }
 
 
 
 
 
 public static float RevDistanceDamageMod(
      this Weapon weapon,
      Vector3 attackPos,
      ICombatant target,
      bool log = true)
    {
      float num1 = weapon.DistantVariance();
      float num2 = 1f;
      float num3 = Vector3.Distance(attackPos, target.get_TargetPosition());
      float num4 = weapon.DamageFalloffStartDistance();
      if ((double) num4 < (double) CustomAmmoCategories.Epsilon)
        num4 = weapon.get_MinRange();
      float num5 = weapon.DamageFalloffEndDistance();
      if ((double) num5 < (double) num4)
        num5 = weapon.get_MediumRange();
      float num6 = 1f;
      if ((double) num3 < (double) num5 && (double) num5 - (double) num4 > (double) CustomAmmoCategories.Epsilon)
        num6 = (float) (((double) num3 - (double) num4) / ((double) num5 - (double) num4));
      if ((double) num1 > 1.0)
        num2 = (double) num3 > (double) num4 ? (float) (1.0 + (double) weapon.RangedDmgFalloffType(num6) * ((double) num1 - 1.0)) : 1f;
      else if ((double) num1 < 1.0)
        num2 = (double) num3 > (double) num4 ? num1 + weapon.RangedDmgFalloffType(num6) * (1f - num1) : num1;
      float num7 = num2;
      if (log)
        CustomAmmoCategoriesLog.Log.M.TWL(0, "defId: " + ((MechComponent) weapon).get_defId() + "\n" + string.Format("baseMultiplier: {0}\n", (object) num1) + string.Format("distance: {0}\n", (object) num3) + string.Format("start distance: {0}\n", (object) num4) + string.Format("end distance: {0}\n", (object) num5) + string.Format("distanceRatio: {0}\n", (object) num6) + string.Format("result: {0}\n", (object) num7));
      return num7;
    }
	
	Here you go, an edited version of the whole function in what should be equivalent code that's way more readable:
public static float DistanceDamageMod(this Weapon weapon, Vector3 attackPos, ICombatant target, bool log = true)
{
  // LOCALS
  float range_Target = Vector3.Distance(attackPos, target.get_TargetPosition());
  float range_F_Start = weapon.DamageFalloffStartDistance();
  float range_F_End = weapon.DamageFalloffEndDistance();
  float smol = 1f / 1000f;
    // DEFAULT: 100%
  float falloff = 1f;
  float output = 1f;

  // INPUT PROTECTION
  if (range_F_Start < smol) range_F_Start = weapon.get_MediumRange();
  if (range_F_End < range_F_Start) range_F_End = weapon.get_MaxRange();

  // GET FALLOFF %
  if ( (range_F_End - range_F_Start) > smol)
    falloff = ((range_Target - range_F_Start) / (range_F_End - range_F_Start));

  // CHECK FOR TRIVIAL CASE
  if (range_Target < range_F_Start)
    output = (falloff > 1.0) ? weapon.DistantVariance() : 1f;
  else //DO THE THING
    output = (falloff > 1.0) ? falloff - weapon.RangedDmgFalloffType(falloff) * (falloff - 1f) 
    : (1.0 - weapon.RangedDmgFalloffType(falloff) * (1.0 - (double) weapon.DistantVariance()));

  if (log) //THEN TAKE NOTES
    CustomAmmoCategoriesLog.Log.M.TWL(0, "defId: "
      + ((MechComponent) weapon).get_defId() + "\n"
      + string.Format("baseMultiplier: {0}\n", (object) weapon.DistantVariance())
      + string.Format("distance: {0}\n", (object) range_Target)
      + string.Format("start distance: {0}\n", (object) range_F_Start)
      + string.Format("end distance {0}\n", (object) range_F_End)
      + string.Format("distanceRatio: {0}\n", (object) falloff)
      + string.Format("result: {0}\n", (object) output));
  return output;
}


=TAC Example=
Mech with 100 armor from 200 and full structure. 
Min crit chance 0.1. 
Weapon has APArmorShardsMod = 0.5 
APMaxArmorThickness = 150
APCritChance = 0.5

Shard Modifier = 1 + (1 - 100/200) = 1.5 
Thickness Modifier = 1 - 100/150 = 0.33333(3)

Overall chance  = 0.1 (Base minimum) * 1.5 (Shards Modifier) * 0.33333 (Thickness Modifier) * 0.5 (AP chance) = 0.025

As armor becomes lower, both modifiers for shard and thickness will rise.



#use this to write to json without unicode errors? future use?
#with open('s1Results/map.json', 'wb') as f:
 #   jdata = json.dumps(r.json(), indent=4, ensure_ascii=False)
  #  f.write(jdata.encode())