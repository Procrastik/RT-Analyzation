   #Distance variance logic:
	#1. If DistantVarianceReversed false
	#  a) if DistantVariance > 1.0 - (0 <= distance <= DamageFalloffStartDistance) damage coeff = DistantVariance
	#                       (DamageFalloffStartDistance < distance < DamageFalloffEndDistance)
#						   damage coeff decrease from DistantVariance(at DamageFalloffStartDistance) to 1(at DamageFalloffEndDistance)
#	  b) if DistantVariance < 1.0 - (0 <= distance <= DamageFalloffStartDistance) damage coeff = 1
#	                       (DamageFalloffStartDistance < distance < DamageFalloffEndDistance)
#						   damage coeff decrease from 1(at DamageFalloffStartDistance) to DistantVariance(at DamageFalloffEndDistance)
#						   if DamageFalloffStartDistance is 0 assumed to be MediumRange
#						   if DamageFalloffEndDistance is less than DamageFalloffStartDistance assumed to be MaxRange
#	2. If DistantVarianceReversed true
#	  a) if DistantVariance > 1.0 - (0 <= distance <= DamageFalloffStartDistance) damage coeff = 1
#	                       (DamageFalloffStartDistance < distance < DamageFalloffEndDistance) 
#						   damage coeff grow from 1(at DamageFalloffStartDistance) to DistantVariance(at DamageFalloffEndDistance)
#						   (DamageFalloffEndDistance <= distance < MaxRange) damage coeff = DistantVariance
#	  b) if DistantVariance < 1.0 - (0 <= distance <= DamageFalloffStartDistance) damage coeff = DistantVariance
#	                       (DamageFalloffStartDistance < distance < DamageFalloffEndDistance) 
#						   damage coeff grow from DistantVariance(at DamageFalloffStartDistance) to 1(at DamageFalloffEndDistance)
#						   (DamageFalloffEndDistance <= distance < MaxRange) damage coeff = 1
#						   if DamageFalloffStartDistance is 0 assumed to be MinRange
#						   if DamageFalloffEndDistance is less than DamageFalloffStartDistance assumed to be MediumRange




	#"DistantVariance": 0.1,
 # "DistantVarianceReversed": true,
 # "isHeatVariation": true,
 # "isStabilityVariation": true,
 # "isDamageVariation": true,
 # "RangedDmgFalloffType": "Linear",
 # "DamageFalloffStartDistance": 30,
#  "DamageFalloffEndDistance": 600,
  
  #"DamageFalloffStartDistance": 0, - distance where damage starts to change, additive per ammo/mode/weapon.
 # "DamageFalloffEndDistance": 0, - distance where damage stops to change, additive per ammo/mode/weapon.
 # "DistantVariance": 0.3, - Distance damage variance addiditve per ammo/mode/weapon
 # "DistantVarianceReversed": false, - Set is distance damage variance is reversed (mode have priority, than ammo, than weapon)
 #"DistantVariance": 0.3, - Distance damage variance addiditve per ammo/mode/weapon
 # "DistantVarianceReversed": false, - Set is distance damage variance is reversed (mode have priority, than ammo, than weapon)
  
  
   #  public static float RangedDmgFalloffType(this Weapon weapon, float value)
    #{
     # switch (weapon.RangedDmgFalloffType())
     # {
      #  case DamageFalloffType.Quadratic:
      #    return value * value;
      #  case DamageFalloffType.Cubic:
      #    return value * value * value;
      #  case DamageFalloffType.SquareRoot:
      #    return Mathf.Sqrt(value);
      #  case DamageFalloffType.Log10:
      #    return Mathf.Log10(value);
      #  case DamageFalloffType.LogE:
      #    return Mathf.Log(value);
      #  case DamageFalloffType.Exp:
      #    return Mathf.Exp(value);
      #  case DamageFalloffType.Linear:
      #    return value;
      #  default:
      #    return value * value;
      #}
  
  public static float DistanceDamageMod(
      this Weapon weapon,
      Vector3 attackPos,
      ICombatant target,
      bool log = true)
    {
      float num1 = weapon.DistantVariance();
      float num2 = 1f;
      float num3 = Vector3.Distance(attackPos, target.get_TargetPosition());
      float num4 = weapon.DamageFalloffStartDistance();
      if ((double) num4 < (double) CustomAmmoCategories.Epsilon)
        num4 = weapon.get_MediumRange();
      float num5 = weapon.DamageFalloffEndDistance();
      if ((double) num5 < (double) num4)
        num5 = weapon.get_MaxRange();
      float num6 = 1f;
      if ((double) num5 - (double) num4 > (double) CustomAmmoCategories.Epsilon)
        num6 = (float) (((double) num3 - (double) num4) / ((double) num5 - (double) num4));
		#num6 (distanceratio) = 888 - 720 / 1440 - 720
      if ((double) num1 > 1.0)
        num2 = (double) num3 > (double) num4 ? num1 - weapon.RangedDmgFalloffType(num6) * (num1 - 1f) : num1;
      else if ((double) num1 < 1.0)
        num2 = (double) num3 > (double) num4 ? (float) (1.0 - (double) weapon.RangedDmgFalloffType(num6) * (1.0 - (double) num1)) : 1f;
      float num7 = num2;
      if (log)
        CustomAmmoCategoriesLog.Log.M.TWL(0, "defId: " + ((MechComponent) weapon).get_defId() + "\n" + string.Format("baseMultiplier: {0}\n", (object) num1) + string.Format("distance: {0}\n", (object) num3) + string.Format("start distance: {0}\n", (object) num4) + string.Format("end distance {0}\n", (object) num5) + string.Format("distanceRatio: {0}\n", (object) num6) + string.Format("result: {0}\n", (object) num7));
      return num7;
    }
 
 
 
 
 
 public static float RevDistanceDamageMod(
      this Weapon weapon,
      Vector3 attackPos,
      ICombatant target,
      bool log = true)
    {
      float num1 = weapon.DistantVariance();
      float num2 = 1f;
      float num3 = Vector3.Distance(attackPos, target.get_TargetPosition());
      float num4 = weapon.DamageFalloffStartDistance();
      if ((double) num4 < (double) CustomAmmoCategories.Epsilon)
        num4 = weapon.get_MinRange();
      float num5 = weapon.DamageFalloffEndDistance();
      if ((double) num5 < (double) num4)
        num5 = weapon.get_MediumRange();
      float num6 = 1f;
      if ((double) num3 < (double) num5 && (double) num5 - (double) num4 > (double) CustomAmmoCategories.Epsilon)
        num6 = (float) (((double) num3 - (double) num4) / ((double) num5 - (double) num4));
      if ((double) num1 > 1.0)
        num2 = (double) num3 > (double) num4 ? (float) (1.0 + (double) weapon.RangedDmgFalloffType(num6) * ((double) num1 - 1.0)) : 1f;
      else if ((double) num1 < 1.0)
        num2 = (double) num3 > (double) num4 ? num1 + weapon.RangedDmgFalloffType(num6) * (1f - num1) : num1;
      float num7 = num2;
      if (log)
        CustomAmmoCategoriesLog.Log.M.TWL(0, "defId: " + ((MechComponent) weapon).get_defId() + "\n" + string.Format("baseMultiplier: {0}\n", (object) num1) + string.Format("distance: {0}\n", (object) num3) + string.Format("start distance: {0}\n", (object) num4) + string.Format("end distance: {0}\n", (object) num5) + string.Format("distanceRatio: {0}\n", (object) num6) + string.Format("result: {0}\n", (object) num7));
      return num7;
    }